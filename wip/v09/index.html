<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Dimensions of Meaning</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    overflow: hidden;
    height: 100vh;
    width: 100vw;
    display: flex;
    background: #0a0a0f;
  }

  /* ---- Left narrative panel ---- */
  #narrative-panel {
    width: 40%;
    min-width: 340px;
    height: 100vh;
    background: #fafafa;
    display: flex;
    flex-direction: column;
    position: relative;
    z-index: 10;
    box-shadow: 4px 0 30px rgba(0,0,0,0.3);
  }

  #narrative-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
    padding: 3rem 2.5rem;
    overflow-y: auto;
  }

  .stage-label {
    font-size: 0.75rem;
    font-weight: 600;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    color: #888;
    margin-bottom: 1rem;
  }

  .stage-title {
    font-size: 1.9rem;
    font-weight: 700;
    color: #111;
    line-height: 1.25;
    margin-bottom: 1.2rem;
  }

  .stage-body {
    font-size: 1.05rem;
    line-height: 1.7;
    color: #444;
    font-weight: 400;
  }

  .stage-body p { margin-bottom: 0.9rem; }

  .word-tag {
    display: inline-block;
    padding: 0.1em 0.45em;
    border-radius: 4px;
    font-weight: 600;
    font-size: 0.95em;
    margin: 0 0.05em;
  }

  .word-chicken   { background: rgba(255,183,77,0.2);  color: #e68a00; }
  .word-salmon    { background: rgba(239,83,80,0.2);   color: #c62828; }
  .word-dog       { background: rgba(66,165,245,0.2);  color: #1565c0; }
  .word-memory    { background: rgba(171,71,188,0.2);  color: #7b1fa2; }
  .word-cookbook   { background: rgba(102,187,106,0.2); color: #2e7d32; }

  /* ---- Navigation ---- */
  #nav-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1.2rem 2.5rem;
    border-top: 1px solid #e0e0e0;
    background: #fff;
  }

  .nav-btn {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.65rem 1.5rem;
    border: 2px solid #222;
    border-radius: 8px;
    background: #fff;
    color: #222;
    font-size: 0.95rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    font-family: inherit;
  }

  .nav-btn:hover:not(:disabled) {
    background: #222;
    color: #fff;
  }

  .nav-btn:disabled {
    opacity: 0.25;
    cursor: default;
  }

  .nav-btn svg {
    width: 18px;
    height: 18px;
    fill: currentColor;
  }

  /* ---- Progress dots ---- */
  #progress {
    display: flex;
    gap: 0.6rem;
    align-items: center;
  }

  .dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: #ccc;
    transition: all 0.35s;
  }

  .dot.active {
    background: #222;
    transform: scale(1.3);
  }

  .dot.visited {
    background: #888;
  }

  /* ---- 3D canvas area ---- */
  #viz-panel {
    flex: 1;
    position: relative;
    height: 100vh;
  }

  #viz-panel canvas {
    display: block;
  }

  /* Axis labels overlaid on 3D */
  .axis-label {
    position: absolute;
    color: rgba(255,255,255,0.7);
    font-size: 0.8rem;
    font-weight: 600;
    letter-spacing: 0.06em;
    text-transform: uppercase;
    pointer-events: none;
    transition: opacity 0.6s;
    text-shadow: 0 0 8px rgba(0,0,0,0.8);
  }

  /* ---- Slide transitions ---- */
  #narrative-content {
    transition: opacity 0.35s ease;
  }
  #narrative-content.fading { opacity: 0; }

  /* ---- Responsive ---- */
  @media (max-width: 800px) {
    body { flex-direction: column; }
    #narrative-panel { width: 100%; height: 45vh; min-width: unset; }
    #viz-panel { height: 55vh; }
    #narrative-content { padding: 1.5rem; }
    .stage-title { font-size: 1.4rem; }
  }
</style>
</head>
<body>

<!-- Left panel: narrative -->
<div id="narrative-panel">
  <div id="narrative-content"></div>
  <div id="nav-bar">
    <button class="nav-btn" id="btn-prev" disabled>
      <svg viewBox="0 0 24 24"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>
      Previous
    </button>
    <div id="progress"></div>
    <button class="nav-btn" id="btn-next">
      Next
      <svg viewBox="0 0 24 24"><path d="M8.59 16.59L10 18l6-6-6-6-1.41 1.41L13.17 12z"/></svg>
    </button>
  </div>
</div>

<!-- Right panel: Three.js -->
<div id="viz-panel"></div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

/* ===================================================================
   DATA
   =================================================================== */

const WORDS = [
  { name: 'Chicken',  animal: 8, food: 9, abs: 1, color: 0xffb74d, cssClass: 'word-chicken' },
  { name: 'Salmon',   animal: 7, food: 8, abs: 1, color: 0xef5350, cssClass: 'word-salmon' },
  { name: 'Dog',      animal: 9, food: 2, abs: 1, color: 0x42a5f5, cssClass: 'word-dog' },
  { name: 'Memory',   animal: 1, food: 1, abs: 9, color: 0xab47bc, cssClass: 'word-memory' },
  { name: 'Cookbook',  animal: 1, food: 8, abs: 3, color: 0x66bb6a, cssClass: 'word-cookbook' },
];

// Deterministic 1D jumbled positions (spread roughly evenly on x)
const JUMBLED_X = [2, 7, 5, 0, 9];

/* ===================================================================
   STAGE DEFINITIONS
   =================================================================== */

function tag(word) {
  return `<span class="word-tag ${word.cssClass}">${word.name}</span>`;
}

const STAGES = [
  {
    label: 'Stage 1 of 5',
    title: 'Five words. How are they related?',
    body: `<p>Consider these five words: ${WORDS.map(w => tag(w)).join(', ')}.</p>
           <p>Right now they're just points on a line &mdash; there's no structure, no meaning. They could be in any order.</p>
           <p>But language models don't see words this way. They place words in a space where <strong>position encodes meaning</strong>.</p>
           <p>Let's see how.</p>`,
    getPositions: () => WORDS.map((w, i) => ({
      x: JUMBLED_X[i] - 4.5,
      y: 0,
      z: 0,
    })),
    camera: { x: 0, y: 0, z: 18 },
    target: { x: 0, y: 0, z: 0 },
    showAxes: [],
  },
  {
    label: 'Stage 2 of 5',
    title: "Dimension 1: How 'Animal' is it?",
    body: `<p>Our first dimension measures how strongly each word relates to <strong>animals</strong>.</p>
           <p>${tag(WORDS[2])} scores highest (9) &mdash; it's the most animal-like word. ${tag(WORDS[0])} (8) and ${tag(WORDS[1])} (7) are close behind &mdash; they're animals too, even if we also eat them.</p>
           <p>${tag(WORDS[3])} and ${tag(WORDS[4])} score low (1 each) &mdash; neither has much to do with animals.</p>
           <p>Already, a pattern emerges: the <em>animal words</em> cluster to the right.</p>`,
    getPositions: () => WORDS.map(w => ({
      x: w.animal - 5,
      y: 0,
      z: 0,
    })),
    camera: { x: 0, y: 0, z: 18 },
    target: { x: 0, y: 0, z: 0 },
    showAxes: ['animal'],
  },
  {
    label: 'Stage 3 of 5',
    title: "Dimension 2: How 'Food' is it?",
    body: `<p>Now we add a second dimension: how strongly each word relates to <strong>food</strong>.</p>
           <p>${tag(WORDS[0])} (9) and ${tag(WORDS[1])} (8) rise high &mdash; both are common foods. ${tag(WORDS[4])} (8) also rises &mdash; a cookbook is all about food.</p>
           <p>${tag(WORDS[2])} drops low on the food axis (2) &mdash; dogs aren't food (usually). And ${tag(WORDS[3])} stays at the bottom (1).</p>
           <p>Notice how ${tag(WORDS[0])} and ${tag(WORDS[4])} are now near each other &mdash; both score high on food, though for different reasons.</p>`,
    getPositions: () => WORDS.map(w => ({
      x: w.animal - 5,
      y: w.food - 5,
      z: 0,
    })),
    camera: { x: 0, y: 0, z: 18 },
    target: { x: 0, y: 0, z: 0 },
    showAxes: ['animal', 'food'],
  },
  {
    label: 'Stage 4 of 5',
    title: "Dimension 3: How 'Abstract' is it?",
    body: `<p>The third dimension captures <strong>abstractness</strong> &mdash; is the word a concrete, physical thing, or an abstract concept?</p>
           <p>${tag(WORDS[3])} leaps forward (9) &mdash; it's the only truly abstract word here. ${tag(WORDS[4])} moves slightly (3) &mdash; it's a physical object but represents knowledge.</p>
           <p>The rest &mdash; ${tag(WORDS[0])}, ${tag(WORDS[1])}, ${tag(WORDS[2])} &mdash; stay near the back (1). They're all concrete, tangible things.</p>
           <p>${tag(WORDS[3])} is now clearly <em>separated</em> from every other word. Three dimensions reveal what one dimension could not.</p>`,
    getPositions: () => WORDS.map(w => ({
      x: w.animal - 5,
      y: w.food - 5,
      z: w.abs - 5,
    })),
    camera: { x: 12, y: 8, z: 12 },
    target: { x: 0, y: 0, z: 0 },
    showAxes: ['animal', 'food', 'abstractness'],
  },
  {
    label: 'Stage 5 of 5',
    title: 'More dimensions, richer meaning',
    body: `<p>Real language models use <strong>hundreds or thousands</strong> of dimensions &mdash; not just three. Each dimension captures a different facet of meaning: sentiment, formality, temporality, and countless others.</p>
           <p>In this space, words with similar meanings land near each other. ${tag(WORDS[0])} and ${tag(WORDS[1])} are close &mdash; both are edible animals. ${tag(WORDS[3])} is far from everything else &mdash; it's abstract and unrelated to food or animals.</p>
           <p>This is the core idea behind <strong>word embeddings</strong>: meaning becomes geometry. Similarity becomes distance. And machines can work with geometry.</p>`,
    getPositions: () => WORDS.map(w => ({
      x: w.animal - 5,
      y: w.food - 5,
      z: w.abs - 5,
    })),
    camera: { x: 14, y: 10, z: 14 },
    target: { x: 0, y: 0, z: 0 },
    showAxes: ['animal', 'food', 'abstractness'],
    showConnections: true,
  },
];

/* ===================================================================
   THREE.JS SETUP
   =================================================================== */

const vizPanel = document.getElementById('viz-panel');
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(vizPanel.clientWidth, vizPanel.clientHeight);
renderer.setClearColor(0x0a0a0f, 1);
vizPanel.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x0a0a0f, 0.012);

const camera = new THREE.PerspectiveCamera(50, vizPanel.clientWidth / vizPanel.clientHeight, 0.1, 200);
camera.position.set(0, 0, 18);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.enablePan = false;
controls.minDistance = 8;
controls.maxDistance = 40;
controls.autoRotate = false;
controls.autoRotateSpeed = 0.5;

// Lights
const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
scene.add(ambientLight);
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(10, 15, 10);
scene.add(dirLight);
const pointLight = new THREE.PointLight(0x6666ff, 0.3, 50);
pointLight.position.set(-5, 5, 5);
scene.add(pointLight);

// Subtle grid
const gridHelper = new THREE.GridHelper(20, 20, 0x222233, 0x151520);
gridHelper.material.transparent = true;
gridHelper.material.opacity = 0.4;
scene.add(gridHelper);

/* ===================================================================
   WORD SPHERES & LABELS
   =================================================================== */

const wordObjects = WORDS.map((w, i) => {
  // Sphere
  const geo = new THREE.SphereGeometry(0.35, 32, 32);
  const mat = new THREE.MeshStandardMaterial({
    color: w.color,
    emissive: w.color,
    emissiveIntensity: 0.35,
    roughness: 0.3,
    metalness: 0.1,
  });
  const mesh = new THREE.Mesh(geo, mat);

  // Glow sphere
  const glowGeo = new THREE.SphereGeometry(0.55, 32, 32);
  const glowMat = new THREE.MeshBasicMaterial({
    color: w.color,
    transparent: true,
    opacity: 0.12,
  });
  const glow = new THREE.Mesh(glowGeo, glowMat);
  mesh.add(glow);

  scene.add(mesh);

  // Text label using canvas
  const label = makeTextSprite(w.name, w.color);
  scene.add(label);

  return { mesh, label, glow, targetPos: new THREE.Vector3() };
});

function makeTextSprite(text, color) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = 256;
  canvas.height = 64;

  ctx.font = 'bold 32px Inter, Arial, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  // Background pill
  const metrics = ctx.measureText(text);
  const pw = metrics.width + 24;
  const ph = 40;
  const px = (canvas.width - pw) / 2;
  const py = (canvas.height - ph) / 2;
  ctx.fillStyle = 'rgba(10,10,15,0.75)';
  roundRect(ctx, px, py, pw, ph, 8);
  ctx.fill();

  // Text
  const c = new THREE.Color(color);
  ctx.fillStyle = `rgb(${Math.floor(c.r*255)},${Math.floor(c.g*255)},${Math.floor(c.b*255)})`;
  ctx.fillText(text, canvas.width / 2, canvas.height / 2 + 1);

  const tex = new THREE.CanvasTexture(canvas);
  tex.minFilter = THREE.LinearFilter;
  const spriteMat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false });
  const sprite = new THREE.Sprite(spriteMat);
  sprite.scale.set(3, 0.75, 1);
  return sprite;
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

/* ===================================================================
   AXES
   =================================================================== */

const axisGroup = new THREE.Group();
scene.add(axisGroup);

const AXIS_LEN = 6;
const AXIS_DEFS = {
  animal: {
    dir: new THREE.Vector3(1, 0, 0),
    color: 0x42a5f5,
    labelText: 'Animal',
    labelOffset: new THREE.Vector3(AXIS_LEN + 1.2, 0, 0),
  },
  food: {
    dir: new THREE.Vector3(0, 1, 0),
    color: 0xffb74d,
    labelText: 'Food',
    labelOffset: new THREE.Vector3(0, AXIS_LEN + 1.2, 0),
  },
  abstractness: {
    dir: new THREE.Vector3(0, 0, 1),
    color: 0xab47bc,
    labelText: 'Abstractness',
    labelOffset: new THREE.Vector3(0, 0, AXIS_LEN + 1.2),
  },
};

const axisObjects = {};

Object.entries(AXIS_DEFS).forEach(([key, def]) => {
  // Line from -AXIS_LEN to +AXIS_LEN
  const points = [
    def.dir.clone().multiplyScalar(-AXIS_LEN),
    def.dir.clone().multiplyScalar(AXIS_LEN),
  ];
  const geo = new THREE.BufferGeometry().setFromPoints(points);
  const mat = new THREE.LineBasicMaterial({ color: def.color, transparent: true, opacity: 0 });
  const line = new THREE.Line(geo, mat);
  axisGroup.add(line);

  // Arrowhead
  const coneGeo = new THREE.ConeGeometry(0.12, 0.4, 8);
  const coneMat = new THREE.MeshBasicMaterial({ color: def.color, transparent: true, opacity: 0 });
  const cone = new THREE.Mesh(coneGeo, coneMat);
  cone.position.copy(def.dir.clone().multiplyScalar(AXIS_LEN));
  // Rotate cone to point along axis direction
  if (key === 'animal') cone.rotation.z = -Math.PI / 2;
  else if (key === 'food') cone.rotation.z = 0;
  else if (key === 'abstractness') cone.rotation.x = Math.PI / 2;
  axisGroup.add(cone);

  // Label sprite
  const label = makeAxisLabel(def.labelText, def.color);
  label.position.copy(def.labelOffset);
  label.material.opacity = 0;
  axisGroup.add(label);

  axisObjects[key] = { line, cone, label, targetOpacity: 0 };
});

function makeAxisLabel(text, color) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = 256;
  canvas.height = 48;

  ctx.font = 'bold 24px Inter, Arial, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  const c = new THREE.Color(color);
  ctx.fillStyle = `rgba(${Math.floor(c.r*255)},${Math.floor(c.g*255)},${Math.floor(c.b*255)},0.9)`;
  ctx.fillText(text, canvas.width / 2, canvas.height / 2);

  const tex = new THREE.CanvasTexture(canvas);
  tex.minFilter = THREE.LinearFilter;
  const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false });
  const sprite = new THREE.Sprite(mat);
  sprite.scale.set(3.5, 0.65, 1);
  return sprite;
}

/* ===================================================================
   CONNECTION LINES (Stage 5)
   =================================================================== */

const connectionGroup = new THREE.Group();
scene.add(connectionGroup);
let connectionLines = [];

function buildConnections() {
  // Remove old
  connectionLines.forEach(l => connectionGroup.remove(l));
  connectionLines = [];

  const positions = STAGES[4].getPositions();
  for (let i = 0; i < WORDS.length; i++) {
    for (let j = i + 1; j < WORDS.length; j++) {
      const pi = positions[i];
      const pj = positions[j];
      const dist = Math.sqrt((pi.x-pj.x)**2 + (pi.y-pj.y)**2 + (pi.z-pj.z)**2);
      // Only show connections between close words (distance < 6)
      const alpha = Math.max(0, 1 - dist / 10) * 0.35;
      if (alpha < 0.02) continue;

      const geo = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(pi.x, pi.y, pi.z),
        new THREE.Vector3(pj.x, pj.y, pj.z),
      ]);

      // Blend colors
      const ci = new THREE.Color(WORDS[i].color);
      const cj = new THREE.Color(WORDS[j].color);
      const midColor = ci.clone().lerp(cj, 0.5);

      const mat = new THREE.LineBasicMaterial({
        color: midColor,
        transparent: true,
        opacity: 0,
      });
      const line = new THREE.Line(geo, mat);
      line.userData.targetOpacity = alpha;
      connectionGroup.add(line);
      connectionLines.push(line);
    }
  }
}

buildConnections();

/* ===================================================================
   STAGE MANAGEMENT
   =================================================================== */

let currentStage = 0;
let animating = false;

const narrativeContent = document.getElementById('narrative-content');
const btnPrev = document.getElementById('btn-prev');
const btnNext = document.getElementById('btn-next');
const progressContainer = document.getElementById('progress');

// Build progress dots
STAGES.forEach((_, i) => {
  const dot = document.createElement('div');
  dot.className = 'dot' + (i === 0 ? ' active' : '');
  dot.addEventListener('click', () => goToStage(i));
  dot.style.cursor = 'pointer';
  progressContainer.appendChild(dot);
});

function updateNarrative(stageIdx) {
  const s = STAGES[stageIdx];
  narrativeContent.classList.add('fading');
  setTimeout(() => {
    narrativeContent.innerHTML = `
      <div class="stage-label">${s.label}</div>
      <h2 class="stage-title">${s.title}</h2>
      <div class="stage-body">${s.body}</div>
    `;
    narrativeContent.classList.remove('fading');
  }, 300);
}

function updateProgress(stageIdx) {
  const dots = progressContainer.querySelectorAll('.dot');
  dots.forEach((d, i) => {
    d.classList.remove('active', 'visited');
    if (i === stageIdx) d.classList.add('active');
    else if (i < stageIdx) d.classList.add('visited');
  });
}

function updateButtons(stageIdx) {
  btnPrev.disabled = stageIdx === 0;
  btnNext.disabled = stageIdx === STAGES.length - 1;
  btnNext.innerHTML = stageIdx === STAGES.length - 1
    ? 'Done'
    : 'Next <svg viewBox="0 0 24 24"><path d="M8.59 16.59L10 18l6-6-6-6-1.41 1.41L13.17 12z"/></svg>';
}

/* ===================================================================
   ANIMATION SYSTEM
   =================================================================== */

const animState = {
  cameraTarget: new THREE.Vector3(),
  controlsTarget: new THREE.Vector3(),
  wordPositions: WORDS.map(() => new THREE.Vector3()),
  axisOpacities: { animal: 0, food: 0, abstractness: 0 },
  showConnections: false,
  autoRotate: false,
};

function setTargetsForStage(stageIdx) {
  const s = STAGES[stageIdx];
  const positions = s.getPositions();

  positions.forEach((p, i) => {
    wordObjects[i].targetPos.set(p.x, p.y, p.z);
  });

  animState.cameraTarget.set(s.camera.x, s.camera.y, s.camera.z);
  animState.controlsTarget.set(s.target.x, s.target.y, s.target.z);

  // Axis visibility
  Object.keys(axisObjects).forEach(key => {
    axisObjects[key].targetOpacity = s.showAxes.includes(key) ? 0.6 : 0;
  });

  animState.showConnections = !!s.showConnections;
  animState.autoRotate = stageIdx >= 3;
}

function goToStage(idx) {
  if (idx < 0 || idx >= STAGES.length || idx === currentStage) return;
  currentStage = idx;
  setTargetsForStage(idx);
  updateNarrative(idx);
  updateProgress(idx);
  updateButtons(idx);
}

// Initialize
setTargetsForStage(0);
updateNarrative(0);
updateProgress(0);
updateButtons(0);

// Set initial positions immediately
const initPositions = STAGES[0].getPositions();
initPositions.forEach((p, i) => {
  wordObjects[i].mesh.position.set(p.x, p.y, p.z);
  wordObjects[i].label.position.set(p.x, p.y + 0.8, p.z);
});

/* ===================================================================
   EVENTS
   =================================================================== */

btnNext.addEventListener('click', () => goToStage(currentStage + 1));
btnPrev.addEventListener('click', () => goToStage(currentStage - 1));

document.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowRight' || e.key === ' ') {
    e.preventDefault();
    goToStage(currentStage + 1);
  } else if (e.key === 'ArrowLeft') {
    e.preventDefault();
    goToStage(currentStage - 1);
  }
});

window.addEventListener('resize', () => {
  const w = vizPanel.clientWidth;
  const h = vizPanel.clientHeight;
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
});

/* ===================================================================
   RENDER LOOP
   =================================================================== */

const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const dt = Math.min(clock.getDelta(), 0.05);
  const t = clock.getElapsedTime();
  const lerpSpeed = 2.5 * dt;

  // Lerp word positions
  wordObjects.forEach((wo, i) => {
    wo.mesh.position.lerp(wo.targetPos, lerpSpeed);
    wo.label.position.set(
      wo.mesh.position.x,
      wo.mesh.position.y + 0.8,
      wo.mesh.position.z
    );

    // Subtle float animation
    wo.mesh.position.y += Math.sin(t * 1.2 + i * 1.7) * 0.003;

    // Pulse glow
    wo.glow.material.opacity = 0.08 + Math.sin(t * 2 + i * 1.3) * 0.04;
  });

  // Lerp camera
  camera.position.lerp(animState.cameraTarget, lerpSpeed * 0.7);
  controls.target.lerp(animState.controlsTarget, lerpSpeed * 0.7);

  // Auto-rotate for 3D stages
  controls.autoRotate = animState.autoRotate;

  // Lerp axis opacities
  Object.entries(axisObjects).forEach(([key, ao]) => {
    const target = ao.targetOpacity;
    ao.line.material.opacity += (target - ao.line.material.opacity) * lerpSpeed * 1.5;
    ao.cone.material.opacity = ao.line.material.opacity;
    ao.label.material.opacity = ao.line.material.opacity;
  });

  // Connection lines
  connectionLines.forEach(line => {
    const target = animState.showConnections ? line.userData.targetOpacity : 0;
    line.material.opacity += (target - line.material.opacity) * lerpSpeed;
  });

  // Grid rotation on y for subtle effect
  gridHelper.rotation.y = t * 0.02;

  controls.update();
  renderer.render(scene, camera);
}

animate();

</script>
</body>
</html>
