<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Context Window</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    overflow: hidden;
    height: 100vh;
    width: 100vw;
    display: flex;
    background: #0a0a0f;
  }

  /* ---- Left narrative panel ---- */
  #narrative-panel {
    width: 40%;
    min-width: 340px;
    height: 100vh;
    background: #fafafa;
    display: flex;
    flex-direction: column;
    position: relative;
    z-index: 10;
    box-shadow: 4px 0 30px rgba(0,0,0,0.3);
  }

  #narrative-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
    padding: 3rem 2.5rem;
    overflow-y: auto;
  }

  .stage-label {
    font-size: 0.75rem;
    font-weight: 600;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    color: #888;
    margin-bottom: 1rem;
  }

  .stage-title {
    font-size: 1.9rem;
    font-weight: 700;
    color: #111;
    line-height: 1.25;
    margin-bottom: 1.2rem;
  }

  .stage-body {
    font-size: 1.05rem;
    line-height: 1.7;
    color: #444;
    font-weight: 400;
  }

  .stage-body p { margin-bottom: 0.9rem; }

  .highlight {
    display: inline-block;
    padding: 0.1em 0.45em;
    border-radius: 4px;
    font-weight: 600;
    font-size: 0.95em;
    margin: 0 0.05em;
  }

  .hl-window  { background: rgba(66,165,245,0.15);  color: #1565c0; }
  .hl-token   { background: rgba(255,183,77,0.2);    color: #e68a00; }
  .hl-good    { background: rgba(102,187,106,0.2);   color: #2e7d32; }
  .hl-bad     { background: rgba(239,83,80,0.15);    color: #c62828; }
  .hl-context { background: rgba(171,71,188,0.15);   color: #7b1fa2; }

  /* ---- Navigation ---- */
  #nav-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1.2rem 2.5rem;
    border-top: 1px solid #e0e0e0;
    background: #fff;
  }

  .nav-btn {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.65rem 1.5rem;
    border: 2px solid #222;
    border-radius: 8px;
    background: #fff;
    color: #222;
    font-size: 0.95rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    font-family: inherit;
  }

  .nav-btn:hover:not(:disabled) {
    background: #222;
    color: #fff;
  }

  .nav-btn:disabled {
    opacity: 0.25;
    cursor: default;
  }

  .nav-btn svg {
    width: 18px;
    height: 18px;
    fill: currentColor;
  }

  /* ---- Progress dots ---- */
  #progress {
    display: flex;
    gap: 0.6rem;
    align-items: center;
  }

  .dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: #ccc;
    transition: all 0.35s;
  }

  .dot.active {
    background: #222;
    transform: scale(1.3);
  }

  .dot.visited {
    background: #888;
  }

  /* ---- 3D canvas area ---- */
  #viz-panel {
    flex: 1;
    position: relative;
    height: 100vh;
  }

  #viz-panel canvas {
    display: block;
  }

  /* ---- Slide transitions ---- */
  #narrative-content {
    transition: opacity 0.35s ease;
  }
  #narrative-content.fading { opacity: 0; }

  /* ---- Responsive ---- */
  @media (max-width: 800px) {
    body { flex-direction: column; }
    #narrative-panel { width: 100%; height: 45vh; min-width: unset; }
    #viz-panel { height: 55vh; }
    #narrative-content { padding: 1.5rem; }
    .stage-title { font-size: 1.4rem; }
  }
</style>
</head>
<body>

<!-- Left panel: narrative -->
<div id="narrative-panel">
  <div id="narrative-content"></div>
  <div id="nav-bar">
    <button class="nav-btn" id="btn-prev" disabled>
      <svg viewBox="0 0 24 24"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>
      Previous
    </button>
    <div id="progress"></div>
    <button class="nav-btn" id="btn-next">
      Next
      <svg viewBox="0 0 24 24"><path d="M8.59 16.59L10 18l6-6-6-6-1.41 1.41L13.17 12z"/></svg>
    </button>
  </div>
</div>

<!-- Right panel: Three.js -->
<div id="viz-panel"></div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

/* ===================================================================
   DATA
   =================================================================== */

const SENTENCE_WORDS = ['The', 'best', 'recipe', 'for', 'chicken', 'soup', 'is'];
const WORD_COLORS = [0x888888, 0x888888, 0x66bb6a, 0x888888, 0xffb74d, 0xef5350, 0x888888];

// Long text for overflow slide
const LONG_TEXT = [
  'Once', 'upon', 'a', 'time', 'in', 'a', 'land',
  'far', 'away', 'there', 'lived', 'a', 'wise',
  'old', 'wizard', 'who', 'knew', 'the', 'secrets'
];

/* ===================================================================
   STAGE DEFINITIONS
   =================================================================== */

const STAGES = [
  {
    label: 'Stage 1 of 5',
    title: 'The model has a memory limit',
    body: `<p>An LLM can only "see" a fixed number of <span class="highlight hl-token">tokens</span> at once. This is the <span class="highlight hl-window">context window</span>.</p>
           <p>Think of it as a frame that slides over text. The model can read and reason about everything inside the frame, but nothing outside it exists as far as the model is concerned.</p>
           <p>The window shown here contains a short sentence. Every word is visible, so the model can understand the full meaning.</p>`,
    camera: { x: 0, y: 2, z: 20 },
    target: { x: 0, y: 0, z: 0 },
  },
  {
    label: 'Stage 2 of 5',
    title: 'Short context: limited understanding',
    body: `<p>With a <span class="highlight hl-bad">tiny context window</span> of just 4 tokens, the model can only see <strong>"for chicken soup is"</strong>.</p>
           <p>The words <em>"The best recipe"</em> are outside the window &mdash; grayed out, invisible to the model. It has no idea this is about a recipe, or that it's "the best" one.</p>
           <p>Asked to predict the next word, the model guesses something generic: <span class="highlight hl-bad">"good"</span>. Without the full context, it can't do better.</p>`,
    camera: { x: 1, y: 2, z: 20 },
    target: { x: 1, y: 0, z: 0 },
  },
  {
    label: 'Stage 3 of 5',
    title: 'Longer context: richer understanding',
    body: `<p>Now expand the <span class="highlight hl-window">context window</span> to hold all 7 tokens. The model sees the full sentence: <strong>"The best recipe for chicken soup is"</strong>.</p>
           <p>With complete context, connections between words become richer. "Best" modifies "recipe". "Recipe" frames "chicken soup" as an ingredient list, not a living animal.</p>
           <p>The prediction becomes far more specific and meaningful: <span class="highlight hl-good">"grandmother's"</span> &mdash; a word that captures warmth, tradition, and quality.</p>`,
    camera: { x: 1, y: 2, z: 22 },
    target: { x: 0, y: 0, z: 0 },
  },
  {
    label: 'Stage 4 of 5',
    title: 'When context overflows',
    body: `<p>When text exceeds the window, the earliest tokens are <span class="highlight hl-bad">forgotten</span>. They fade away, dropping off the left edge.</p>
           <p>The model loses track of earlier context. It might forget a character's name introduced at the start, miss an important instruction, or contradict something it said before.</p>
           <p>This is a fundamental constraint &mdash; not a bug. The window has a fixed size, and older information must make way for newer text.</p>`,
    camera: { x: 0, y: 4, z: 30 },
    target: { x: 0, y: -1, z: 0 },
  },
  {
    label: 'Stage 5 of 5',
    title: 'Why context length matters',
    body: `<p>This is why <span class="highlight hl-context">context window size</span> matters. Compare two models side by side.</p>
           <p>The <span class="highlight hl-bad">small window</span> model loses context, forgets earlier details, and makes mistakes. It can only hold a fragment of the conversation.</p>
           <p>The <span class="highlight hl-good">large window</span> model retains the full story. It follows plot threads, remembers instructions, and stays consistent across long documents.</p>
           <p>As context windows grow &mdash; from 4K to 128K to 1M tokens &mdash; models become capable of reasoning over entire books, codebases, and conversations.</p>`,
    camera: { x: 0, y: 3, z: 30 },
    target: { x: 0, y: 0, z: 0 },
  },
];

/* ===================================================================
   THREE.JS SETUP
   =================================================================== */

const vizPanel = document.getElementById('viz-panel');
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(vizPanel.clientWidth, vizPanel.clientHeight);
renderer.setClearColor(0x0a0a0f, 1);
vizPanel.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x0a0a0f, 0.008);

const camera3D = new THREE.PerspectiveCamera(50, vizPanel.clientWidth / vizPanel.clientHeight, 0.1, 200);
camera3D.position.set(0, 2, 20);

const controls = new OrbitControls(camera3D, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.enablePan = false;
controls.minDistance = 8;
controls.maxDistance = 50;
controls.autoRotate = false;
controls.autoRotateSpeed = 0.3;

// Lights
scene.add(new THREE.AmbientLight(0xffffff, 0.4));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(10, 15, 10);
scene.add(dirLight);
const pointLight = new THREE.PointLight(0x4488ff, 0.4, 60);
pointLight.position.set(-5, 8, 5);
scene.add(pointLight);

// Subtle grid
const gridHelper = new THREE.GridHelper(30, 30, 0x222233, 0x151520);
gridHelper.material.transparent = true;
gridHelper.material.opacity = 0.3;
scene.add(gridHelper);

/* ===================================================================
   UTILITY: canvas text sprite
   =================================================================== */

function makeTextSprite(text, color, fontSize) {
  fontSize = fontSize || 28;
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = 256;
  canvas.height = 64;

  ctx.font = `bold ${fontSize}px Inter, Arial, sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  const metrics = ctx.measureText(text);
  const pw = metrics.width + 24;
  const ph = 40;
  const px = (canvas.width - pw) / 2;
  const py = (canvas.height - ph) / 2;
  ctx.fillStyle = 'rgba(10,10,15,0.75)';
  roundRect(ctx, px, py, pw, ph, 8);
  ctx.fill();

  const c = new THREE.Color(color);
  ctx.fillStyle = `rgb(${Math.floor(c.r*255)},${Math.floor(c.g*255)},${Math.floor(c.b*255)})`;
  ctx.fillText(text, canvas.width / 2, canvas.height / 2 + 1);

  const tex = new THREE.CanvasTexture(canvas);
  tex.minFilter = THREE.LinearFilter;
  const spriteMat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false });
  const sprite = new THREE.Sprite(spriteMat);
  sprite.scale.set(3, 0.75, 1);
  return sprite;
}

function makePredictionSprite(text, color) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = 512;
  canvas.height = 80;

  ctx.font = 'bold 30px Inter, Arial, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  const metrics = ctx.measureText(text);
  const pw = metrics.width + 40;
  const ph = 50;
  const px = (canvas.width - pw) / 2;
  const py = (canvas.height - ph) / 2;

  ctx.strokeStyle = `rgba(${new THREE.Color(color).r*255|0},${new THREE.Color(color).g*255|0},${new THREE.Color(color).b*255|0},0.6)`;
  ctx.lineWidth = 2;
  ctx.setLineDash([6, 4]);
  roundRect(ctx, px, py, pw, ph, 10);
  ctx.stroke();

  ctx.fillStyle = `rgba(${new THREE.Color(color).r*255|0},${new THREE.Color(color).g*255|0},${new THREE.Color(color).b*255|0},0.12)`;
  roundRect(ctx, px, py, pw, ph, 10);
  ctx.fill();

  ctx.setLineDash([]);
  const c = new THREE.Color(color);
  ctx.fillStyle = `rgb(${Math.floor(c.r*255)},${Math.floor(c.g*255)},${Math.floor(c.b*255)})`;
  ctx.fillText(text, canvas.width / 2, canvas.height / 2 + 1);

  const tex = new THREE.CanvasTexture(canvas);
  tex.minFilter = THREE.LinearFilter;
  const spriteMat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false });
  const sprite = new THREE.Sprite(spriteMat);
  sprite.scale.set(5, 1, 1);
  return sprite;
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

/* ===================================================================
   WINDOW FRAME (glowing border)
   =================================================================== */

function createWindowFrame(width, height, color) {
  const group = new THREE.Group();
  const hw = width / 2;
  const hh = height / 2;

  // Border edges
  const mat = new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.8 });
  const pts = [
    new THREE.Vector3(-hw, -hh, 0),
    new THREE.Vector3( hw, -hh, 0),
    new THREE.Vector3( hw,  hh, 0),
    new THREE.Vector3(-hw,  hh, 0),
    new THREE.Vector3(-hw, -hh, 0),
  ];
  const geo = new THREE.BufferGeometry().setFromPoints(pts);
  const line = new THREE.Line(geo, mat);
  group.add(line);

  // Glow panels (top and bottom bars)
  const glowMat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.06, side: THREE.DoubleSide });
  const panelGeo = new THREE.PlaneGeometry(width, height);
  const panel = new THREE.Mesh(panelGeo, glowMat);
  group.add(panel);

  // Corner accents
  const cornerLen = 0.4;
  const cornerMat = new THREE.LineBasicMaterial({ color, transparent: true, opacity: 1, linewidth: 2 });
  const corners = [
    [[-hw, -hh+cornerLen, 0], [-hw, -hh, 0], [-hw+cornerLen, -hh, 0]],
    [[ hw-cornerLen, -hh, 0], [ hw, -hh, 0], [ hw, -hh+cornerLen, 0]],
    [[ hw, hh-cornerLen, 0], [ hw, hh, 0], [ hw-cornerLen, hh, 0]],
    [[-hw+cornerLen, hh, 0], [-hw, hh, 0], [-hw, hh-cornerLen, 0]],
  ];
  corners.forEach(c => {
    const cGeo = new THREE.BufferGeometry().setFromPoints(c.map(p => new THREE.Vector3(...p)));
    group.add(new THREE.Line(cGeo, cornerMat));
  });

  return group;
}

/* ===================================================================
   SCENE OBJECTS: Per-stage groups
   =================================================================== */

// Shared spacing
const SPACING = 1.6;

// ---- Stage 1: Full sentence in window ----
const stage1Group = new THREE.Group();
scene.add(stage1Group);

const s1Spheres = [];
const s1Labels = [];
const s1Glows = [];

SENTENCE_WORDS.forEach((word, i) => {
  const x = (i - (SENTENCE_WORDS.length - 1) / 2) * SPACING;

  const geo = new THREE.SphereGeometry(0.35, 32, 32);
  const c = WORD_COLORS[i];
  const mat = new THREE.MeshStandardMaterial({
    color: c, emissive: c, emissiveIntensity: 0.35, roughness: 0.3, metalness: 0.1,
  });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, 0, 0);
  stage1Group.add(mesh);

  const glowGeo = new THREE.SphereGeometry(0.55, 32, 32);
  const glowMat = new THREE.MeshBasicMaterial({ color: c, transparent: true, opacity: 0.12 });
  const glow = new THREE.Mesh(glowGeo, glowMat);
  mesh.add(glow);

  const label = makeTextSprite(word, c);
  label.position.set(x, 0.85, 0);
  stage1Group.add(label);

  s1Spheres.push(mesh);
  s1Labels.push(label);
  s1Glows.push(glow);
});

// Window frame for stage 1
const s1FrameWidth = SENTENCE_WORDS.length * SPACING + 1.2;
const s1Frame = createWindowFrame(s1FrameWidth, 2.8, 0x42a5f5);
s1Frame.position.set(0, 0, 0);
stage1Group.add(s1Frame);

// "Context Window" label
const s1WindowLabel = makeTextSprite('Context Window', 0x42a5f5, 22);
s1WindowLabel.position.set(0, 2.2, 0);
stage1Group.add(s1WindowLabel);

// Connection lines between adjacent words
const s1Connections = [];
for (let i = 0; i < SENTENCE_WORDS.length - 1; i++) {
  const x1 = (i - (SENTENCE_WORDS.length - 1) / 2) * SPACING;
  const x2 = ((i+1) - (SENTENCE_WORDS.length - 1) / 2) * SPACING;
  const pts = [new THREE.Vector3(x1, 0, 0), new THREE.Vector3(x2, 0, 0)];
  const geo = new THREE.BufferGeometry().setFromPoints(pts);
  const mat = new THREE.LineBasicMaterial({ color: 0x42a5f5, transparent: true, opacity: 0.2 });
  const line = new THREE.Line(geo, mat);
  stage1Group.add(line);
  s1Connections.push(line);
}

// ---- Stage 2: Small window (4 tokens) ----
const stage2Group = new THREE.Group();
scene.add(stage2Group);

const s2Spheres = [];
const s2Labels = [];
const s2Glows = [];

// Window only covers tokens 3-6: "for chicken soup is"
const s2WindowStart = 3;
const s2WindowEnd = 6;

SENTENCE_WORDS.forEach((word, i) => {
  const x = (i - (SENTENCE_WORDS.length - 1) / 2) * SPACING;
  const inWindow = i >= s2WindowStart && i <= s2WindowEnd;
  const c = inWindow ? WORD_COLORS[i] : 0x333340;

  const geo = new THREE.SphereGeometry(0.35, 32, 32);
  const mat = new THREE.MeshStandardMaterial({
    color: c, emissive: c, emissiveIntensity: inWindow ? 0.35 : 0.05,
    roughness: 0.3, metalness: 0.1,
  });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, 0, 0);
  stage2Group.add(mesh);

  const glowGeo = new THREE.SphereGeometry(0.55, 32, 32);
  const glowMat = new THREE.MeshBasicMaterial({ color: c, transparent: true, opacity: inWindow ? 0.12 : 0.03 });
  const glow = new THREE.Mesh(glowGeo, glowMat);
  mesh.add(glow);

  const label = makeTextSprite(word, inWindow ? WORD_COLORS[i] : 0x444455, inWindow ? 28 : 24);
  label.position.set(x, 0.85, 0);
  stage2Group.add(label);

  s2Spheres.push(mesh);
  s2Labels.push(label);
  s2Glows.push(glow);
});

// Small window frame
const s2CenterX = ((s2WindowStart + s2WindowEnd) / 2 - (SENTENCE_WORDS.length - 1) / 2) * SPACING;
const s2FrameWidth = (s2WindowEnd - s2WindowStart + 1) * SPACING + 1.0;
const s2Frame = createWindowFrame(s2FrameWidth, 2.8, 0xef5350);
s2Frame.position.set(s2CenterX, 0, 0);
stage2Group.add(s2Frame);

const s2WindowLabel = makeTextSprite('4-token window', 0xef5350, 22);
s2WindowLabel.position.set(s2CenterX, 2.2, 0);
stage2Group.add(s2WindowLabel);

// "Outside" labels for grayed-out words
const s2OutsideLabel = makeTextSprite('Outside window', 0x555566, 20);
s2OutsideLabel.position.set(((0 + 2) / 2 - (SENTENCE_WORDS.length - 1) / 2) * SPACING, -1.8, 0);
stage2Group.add(s2OutsideLabel);

// Prediction arrow and label
const s2PredArrowPts = [
  new THREE.Vector3((6 - (SENTENCE_WORDS.length-1)/2) * SPACING + 0.6, 0, 0),
  new THREE.Vector3((6 - (SENTENCE_WORDS.length-1)/2) * SPACING + 2.0, 0, 0),
];
const s2ArrowGeo = new THREE.BufferGeometry().setFromPoints(s2PredArrowPts);
const s2ArrowMat = new THREE.LineBasicMaterial({ color: 0xef5350, transparent: true, opacity: 0.6 });
const s2Arrow = new THREE.Line(s2ArrowGeo, s2ArrowMat);
stage2Group.add(s2Arrow);

const s2Prediction = makePredictionSprite('"good" (?)', 0xef5350);
s2Prediction.position.set((6 - (SENTENCE_WORDS.length-1)/2) * SPACING + 3.0, 0, 0);
stage2Group.add(s2Prediction);

// ---- Stage 3: Full window ----
const stage3Group = new THREE.Group();
scene.add(stage3Group);

const s3Spheres = [];
const s3Labels = [];
const s3Glows = [];

SENTENCE_WORDS.forEach((word, i) => {
  const x = (i - (SENTENCE_WORDS.length - 1) / 2) * SPACING;
  const c = WORD_COLORS[i];

  const geo = new THREE.SphereGeometry(0.35, 32, 32);
  const mat = new THREE.MeshStandardMaterial({
    color: c, emissive: c, emissiveIntensity: 0.4, roughness: 0.3, metalness: 0.1,
  });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, 0, 0);
  stage3Group.add(mesh);

  const glowGeo = new THREE.SphereGeometry(0.55, 32, 32);
  const glowMat = new THREE.MeshBasicMaterial({ color: c, transparent: true, opacity: 0.15 });
  const glow = new THREE.Mesh(glowGeo, glowMat);
  mesh.add(glow);

  const label = makeTextSprite(word, c);
  label.position.set(x, 0.85, 0);
  stage3Group.add(label);

  s3Spheres.push(mesh);
  s3Labels.push(label);
  s3Glows.push(glow);
});

// Full window frame
const s3FrameWidth = SENTENCE_WORDS.length * SPACING + 1.2;
const s3Frame = createWindowFrame(s3FrameWidth, 2.8, 0x66bb6a);
s3Frame.position.set(0, 0, 0);
stage3Group.add(s3Frame);

const s3WindowLabel = makeTextSprite('Full context window', 0x66bb6a, 22);
s3WindowLabel.position.set(0, 2.2, 0);
stage3Group.add(s3WindowLabel);

// Rich connection arcs between words
const s3Connections = [];
for (let i = 0; i < SENTENCE_WORDS.length; i++) {
  for (let j = i + 1; j < SENTENCE_WORDS.length; j++) {
    const x1 = (i - (SENTENCE_WORDS.length - 1) / 2) * SPACING;
    const x2 = (j - (SENTENCE_WORDS.length - 1) / 2) * SPACING;
    const dist = j - i;
    const opacity = Math.max(0.04, 0.25 - dist * 0.03);

    const midX = (x1 + x2) / 2;
    const midY = -0.4 - dist * 0.2;
    const curve = new THREE.QuadraticBezierCurve3(
      new THREE.Vector3(x1, 0, 0),
      new THREE.Vector3(midX, midY, 0),
      new THREE.Vector3(x2, 0, 0),
    );
    const pts = curve.getPoints(20);
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    const c1 = new THREE.Color(WORD_COLORS[i]);
    const c2 = new THREE.Color(WORD_COLORS[j]);
    const blended = c1.clone().lerp(c2, 0.5);
    const mat = new THREE.LineBasicMaterial({ color: blended, transparent: true, opacity });
    const line = new THREE.Line(geo, mat);
    stage3Group.add(line);
    s3Connections.push(line);
  }
}

// Prediction arrow and label
const s3PredArrowPts = [
  new THREE.Vector3((6 - (SENTENCE_WORDS.length-1)/2) * SPACING + 0.6, 0, 0),
  new THREE.Vector3((6 - (SENTENCE_WORDS.length-1)/2) * SPACING + 2.0, 0, 0),
];
const s3ArrowGeo = new THREE.BufferGeometry().setFromPoints(s3PredArrowPts);
const s3ArrowMat = new THREE.LineBasicMaterial({ color: 0x66bb6a, transparent: true, opacity: 0.6 });
const s3Arrow = new THREE.Line(s3ArrowGeo, s3ArrowMat);
stage3Group.add(s3Arrow);

const s3Prediction = makePredictionSprite('"grandmother\'s"', 0x66bb6a);
s3Prediction.position.set((6 - (SENTENCE_WORDS.length-1)/2) * SPACING + 4.5, 0, 0);
stage3Group.add(s3Prediction);

// ---- Stage 4: Overflow ----
const stage4Group = new THREE.Group();
scene.add(stage4Group);

const OVERFLOW_WINDOW_SIZE = 8;
const S4_SPACING = 1.1;
const s4Spheres = [];
const s4Labels = [];
const s4Glows = [];

LONG_TEXT.forEach((word, i) => {
  const x = (i - LONG_TEXT.length / 2) * S4_SPACING;
  const inWindow = i >= LONG_TEXT.length - OVERFLOW_WINDOW_SIZE;
  const distOutside = inWindow ? 0 : (LONG_TEXT.length - OVERFLOW_WINDOW_SIZE - i);
  const fadeFactor = inWindow ? 1 : Math.max(0, 1 - distOutside * 0.12);
  const dropY = inWindow ? 0 : -distOutside * 0.35;

  const baseColor = inWindow ? 0x42a5f5 : 0x333340;
  const c = new THREE.Color(baseColor);

  const geo = new THREE.SphereGeometry(0.22, 24, 24);
  const mat = new THREE.MeshStandardMaterial({
    color: c, emissive: c, emissiveIntensity: inWindow ? 0.3 : 0.02,
    roughness: 0.3, metalness: 0.1,
    transparent: true, opacity: fadeFactor,
  });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, dropY, 0);
  stage4Group.add(mesh);

  const glowGeo = new THREE.SphereGeometry(0.36, 24, 24);
  const glowMat = new THREE.MeshBasicMaterial({
    color: c, transparent: true, opacity: inWindow ? 0.1 : 0.02 * fadeFactor,
  });
  const glow = new THREE.Mesh(glowGeo, glowMat);
  mesh.add(glow);

  // Only label some words to avoid clutter
  if (i % 2 === 0 || inWindow) {
    const label = makeTextSprite(word, inWindow ? 0x42a5f5 : 0x444455, 20);
    label.position.set(x, dropY + 0.6, 0);
    label.material.opacity = fadeFactor;
    stage4Group.add(label);
    s4Labels.push(label);
  }

  s4Spheres.push(mesh);
  s4Glows.push(glow);
});

// Window frame for overflow
const s4WinStartX = (LONG_TEXT.length - OVERFLOW_WINDOW_SIZE - LONG_TEXT.length / 2) * S4_SPACING;
const s4WinEndX = (LONG_TEXT.length - 1 - LONG_TEXT.length / 2) * S4_SPACING;
const s4WinCenterX = (s4WinStartX + s4WinEndX) / 2;
const s4WinWidth = (s4WinEndX - s4WinStartX) + 1.6;
const s4Frame = createWindowFrame(s4WinWidth, 2.4, 0x42a5f5);
s4Frame.position.set(s4WinCenterX, 0, 0);
stage4Group.add(s4Frame);

const s4WindowLabel = makeTextSprite('Context Window', 0x42a5f5, 22);
s4WindowLabel.position.set(s4WinCenterX, 1.8, 0);
stage4Group.add(s4WindowLabel);

const s4ForgottenLabel = makeTextSprite('Forgotten tokens', 0xef5350, 20);
s4ForgottenLabel.position.set(((0 + (LONG_TEXT.length - OVERFLOW_WINDOW_SIZE - 1)) / 2 - LONG_TEXT.length / 2) * S4_SPACING, -4.5, 0);
stage4Group.add(s4ForgottenLabel);

// ---- Stage 5: Side-by-side comparison ----
const stage5Group = new THREE.Group();
scene.add(stage5Group);

// Small window model (left side)
const s5LeftGroup = new THREE.Group();
s5LeftGroup.position.set(-7, 0, 0);
stage5Group.add(s5LeftGroup);

const s5SmallWords = ['the', 'cat', 'sat', 'on', 'the', 'mat', 'and', 'then', 'it', 'jumped', 'over', 'the', 'fence'];
const s5SmallWindowSize = 4;

s5SmallWords.forEach((word, i) => {
  const x = (i - s5SmallWords.length / 2) * 1.1;
  const inWin = i >= s5SmallWords.length - s5SmallWindowSize;
  const distOut = inWin ? 0 : (s5SmallWords.length - s5SmallWindowSize - i);
  const fade = inWin ? 1 : Math.max(0.1, 1 - distOut * 0.15);
  const dropY = inWin ? 0 : -distOut * 0.25;
  const c = inWin ? 0xef5350 : 0x333340;

  const geo = new THREE.SphereGeometry(0.2, 24, 24);
  const mat = new THREE.MeshStandardMaterial({
    color: c, emissive: c, emissiveIntensity: inWin ? 0.3 : 0.02,
    roughness: 0.3, metalness: 0.1, transparent: true, opacity: fade,
  });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, dropY, 0);
  s5LeftGroup.add(mesh);

  const glowGeo = new THREE.SphereGeometry(0.32, 24, 24);
  const glowMat = new THREE.MeshBasicMaterial({ color: c, transparent: true, opacity: inWin ? 0.08 : 0.01 });
  mesh.add(new THREE.Mesh(glowGeo, glowMat));
});

const s5SmallWinStartX = (s5SmallWords.length - s5SmallWindowSize - s5SmallWords.length / 2) * 1.1;
const s5SmallWinEndX = (s5SmallWords.length - 1 - s5SmallWords.length / 2) * 1.1;
const s5SmallFrame = createWindowFrame((s5SmallWinEndX - s5SmallWinStartX) + 1.4, 2.0, 0xef5350);
s5SmallFrame.position.set((s5SmallWinStartX + s5SmallWinEndX) / 2, 0, 0);
s5LeftGroup.add(s5SmallFrame);

const s5SmallLabel = makeTextSprite('Small Window (4K)', 0xef5350, 22);
s5SmallLabel.position.set(0, 2.5, 0);
s5LeftGroup.add(s5SmallLabel);

const s5SmallStatus = makePredictionSprite('Lost context', 0xef5350);
s5SmallStatus.position.set(0, -3.5, 0);
s5SmallStatus.scale.set(4, 0.8, 1);
s5LeftGroup.add(s5SmallStatus);

// Large window model (right side)
const s5RightGroup = new THREE.Group();
s5RightGroup.position.set(7, 0, 0);
stage5Group.add(s5RightGroup);

const s5LargeWords = s5SmallWords.slice();

s5LargeWords.forEach((word, i) => {
  const x = (i - s5LargeWords.length / 2) * 1.1;
  const c = 0x66bb6a;

  const geo = new THREE.SphereGeometry(0.2, 24, 24);
  const mat = new THREE.MeshStandardMaterial({
    color: c, emissive: c, emissiveIntensity: 0.3,
    roughness: 0.3, metalness: 0.1,
  });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, 0, 0);
  s5RightGroup.add(mesh);

  const glowGeo = new THREE.SphereGeometry(0.32, 24, 24);
  const glowMat = new THREE.MeshBasicMaterial({ color: c, transparent: true, opacity: 0.1 });
  mesh.add(new THREE.Mesh(glowGeo, glowMat));
});

const s5LargeWinStartX = (0 - s5LargeWords.length / 2) * 1.1;
const s5LargeWinEndX = (s5LargeWords.length - 1 - s5LargeWords.length / 2) * 1.1;
const s5LargeFrame = createWindowFrame((s5LargeWinEndX - s5LargeWinStartX) + 1.4, 2.0, 0x66bb6a);
s5LargeFrame.position.set((s5LargeWinStartX + s5LargeWinEndX) / 2, 0, 0);
s5RightGroup.add(s5LargeFrame);

const s5LargeLabel = makeTextSprite('Large Window (128K)', 0x66bb6a, 22);
s5LargeLabel.position.set(0, 2.5, 0);
s5RightGroup.add(s5LargeLabel);

const s5LargeStatus = makePredictionSprite('Full context retained', 0x66bb6a);
s5LargeStatus.position.set(0, -3.5, 0);
s5LargeStatus.scale.set(4, 0.8, 1);
s5RightGroup.add(s5LargeStatus);

// Connection arcs for large window
for (let i = 0; i < s5LargeWords.length; i++) {
  for (let j = i + 1; j < s5LargeWords.length; j++) {
    if (Math.random() > 0.35) continue;
    const x1 = (i - s5LargeWords.length / 2) * 1.1;
    const x2 = (j - s5LargeWords.length / 2) * 1.1;
    const dist = j - i;
    const midX = (x1 + x2) / 2;
    const midY = -0.3 - dist * 0.12;
    const curve = new THREE.QuadraticBezierCurve3(
      new THREE.Vector3(x1, 0, 0),
      new THREE.Vector3(midX, midY, 0),
      new THREE.Vector3(x2, 0, 0),
    );
    const pts = curve.getPoints(15);
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    const mat = new THREE.LineBasicMaterial({ color: 0x66bb6a, transparent: true, opacity: 0.12 });
    s5RightGroup.add(new THREE.Line(geo, mat));
  }
}

// Divider line between models
const divPts = [new THREE.Vector3(0, -5, 0), new THREE.Vector3(0, 5, 0)];
const divGeo = new THREE.BufferGeometry().setFromPoints(divPts);
const divMat = new THREE.LineBasicMaterial({ color: 0x333344, transparent: true, opacity: 0.4 });
stage5Group.add(new THREE.Line(divGeo, divMat));

const vsLabel = makeTextSprite('vs', 0x666677, 24);
vsLabel.position.set(0, 3.8, 0);
stage5Group.add(vsLabel);

/* ===================================================================
   STAGE VISIBILITY
   =================================================================== */

const stageGroups = [stage1Group, stage2Group, stage3Group, stage4Group, stage5Group];

// Hide all groups except first
stageGroups.forEach((g, i) => { g.visible = i === 0; });

/* ===================================================================
   STAGE MANAGEMENT
   =================================================================== */

let currentStage = 0;

const narrativeContent = document.getElementById('narrative-content');
const btnPrev = document.getElementById('btn-prev');
const btnNext = document.getElementById('btn-next');
const progressContainer = document.getElementById('progress');

// Build progress dots
STAGES.forEach((_, i) => {
  const dot = document.createElement('div');
  dot.className = 'dot' + (i === 0 ? ' active' : '');
  dot.addEventListener('click', () => goToStage(i));
  dot.style.cursor = 'pointer';
  progressContainer.appendChild(dot);
});

function updateNarrative(stageIdx) {
  const s = STAGES[stageIdx];
  narrativeContent.classList.add('fading');
  setTimeout(() => {
    narrativeContent.innerHTML = `
      <div class="stage-label">${s.label}</div>
      <h2 class="stage-title">${s.title}</h2>
      <div class="stage-body">${s.body}</div>
    `;
    narrativeContent.classList.remove('fading');
  }, 300);
}

function updateProgress(stageIdx) {
  const dots = progressContainer.querySelectorAll('.dot');
  dots.forEach((d, i) => {
    d.classList.remove('active', 'visited');
    if (i === stageIdx) d.classList.add('active');
    else if (i < stageIdx) d.classList.add('visited');
  });
}

function updateButtons(stageIdx) {
  btnPrev.disabled = stageIdx === 0;
  btnNext.disabled = stageIdx === STAGES.length - 1;
  btnNext.innerHTML = stageIdx === STAGES.length - 1
    ? 'Done'
    : 'Next <svg viewBox="0 0 24 24"><path d="M8.59 16.59L10 18l6-6-6-6-1.41 1.41L13.17 12z"/></svg>';
}

/* ===================================================================
   ANIMATION STATE
   =================================================================== */

const animState = {
  cameraTarget: new THREE.Vector3(0, 2, 20),
  controlsTarget: new THREE.Vector3(0, 0, 0),
};

function goToStage(idx) {
  if (idx < 0 || idx >= STAGES.length || idx === currentStage) return;
  currentStage = idx;

  const s = STAGES[idx];
  animState.cameraTarget.set(s.camera.x, s.camera.y, s.camera.z);
  animState.controlsTarget.set(s.target.x, s.target.y, s.target.z);

  // Toggle group visibility
  stageGroups.forEach((g, i) => { g.visible = i === idx; });

  updateNarrative(idx);
  updateProgress(idx);
  updateButtons(idx);
}

// Initialize
updateNarrative(0);
updateProgress(0);
updateButtons(0);

/* ===================================================================
   EVENTS
   =================================================================== */

btnNext.addEventListener('click', () => goToStage(currentStage + 1));
btnPrev.addEventListener('click', () => goToStage(currentStage - 1));

document.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowRight' || e.key === ' ') {
    e.preventDefault();
    goToStage(currentStage + 1);
  } else if (e.key === 'ArrowLeft') {
    e.preventDefault();
    goToStage(currentStage - 1);
  }
});

window.addEventListener('resize', () => {
  const w = vizPanel.clientWidth;
  const h = vizPanel.clientHeight;
  camera3D.aspect = w / h;
  camera3D.updateProjectionMatrix();
  renderer.setSize(w, h);
});

/* ===================================================================
   RENDER LOOP
   =================================================================== */

const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const dt = Math.min(clock.getDelta(), 0.05);
  const t = clock.getElapsedTime();
  const lerpSpeed = 3.0 * dt;

  // Lerp camera
  camera3D.position.lerp(animState.cameraTarget, lerpSpeed * 1.2);
  controls.target.lerp(animState.controlsTarget, lerpSpeed * 1.2);

  // Animate stage 1 spheres (float)
  s1Spheres.forEach((mesh, i) => {
    mesh.position.y = Math.sin(t * 1.2 + i * 1.5) * 0.06;
  });
  s1Labels.forEach((label, i) => {
    label.position.y = 0.85 + Math.sin(t * 1.2 + i * 1.5) * 0.06;
  });

  // Animate stage 2 spheres
  s2Spheres.forEach((mesh, i) => {
    const inWindow = i >= s2WindowStart && i <= s2WindowEnd;
    const baseY = inWindow ? 0 : 0;
    mesh.position.y = baseY + Math.sin(t * 1.0 + i * 1.3) * (inWindow ? 0.05 : 0.02);
  });

  // Animate stage 3 spheres
  s3Spheres.forEach((mesh, i) => {
    mesh.position.y = Math.sin(t * 1.3 + i * 1.7) * 0.06;
  });

  // Animate stage 4: drift forgotten tokens downward slowly
  s4Spheres.forEach((mesh, i) => {
    const inWindow = i >= LONG_TEXT.length - OVERFLOW_WINDOW_SIZE;
    if (inWindow) {
      mesh.position.y = Math.sin(t * 1.1 + i * 0.8) * 0.04;
    } else {
      const distOut = LONG_TEXT.length - OVERFLOW_WINDOW_SIZE - i;
      const baseY = -distOut * 0.35;
      mesh.position.y = baseY + Math.sin(t * 0.5 + i * 0.6) * 0.03 - Math.sin(t * 0.15) * distOut * 0.03;
    }
  });

  // Animate stage 5: pulse glow
  // Subtle pulse on active stage elements
  if (currentStage === 4) {
    controls.autoRotate = false;
  }

  // Grid subtle rotation
  gridHelper.rotation.y = t * 0.015;

  controls.update();
  renderer.render(scene, camera3D);
}

animate();

</script>
</body>
</html>
