<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ch 02: From Embeddings to Completions</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    overflow: hidden;
    height: 100vh;
    width: 100vw;
    display: flex;
    background: #0a0a0f;
  }

  #narrative-panel {
    width: 40%;
    min-width: 340px;
    height: 100vh;
    background: #fafafa;
    display: flex;
    flex-direction: column;
    position: relative;
    z-index: 10;
    box-shadow: 4px 0 30px rgba(0,0,0,0.3);
  }

  #narrative-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
    padding: 3rem 2.5rem;
    overflow-y: auto;
  }

  .stage-label {
    font-size: 0.75rem;
    font-weight: 600;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    color: #888;
    margin-bottom: 1rem;
  }

  .stage-title {
    font-size: 1.9rem;
    font-weight: 700;
    color: #111;
    line-height: 1.25;
    margin-bottom: 1.2rem;
  }

  .stage-body {
    font-size: 1.05rem;
    line-height: 1.7;
    color: #444;
    font-weight: 400;
  }

  .stage-body p { margin-bottom: 0.9rem; }

  .highlight {
    display: inline;
    padding: 0.1em 0.35em;
    border-radius: 4px;
    font-weight: 600;
    font-size: 0.95em;
  }

  .hl-token    { background: rgba(255,183,77,0.2);  color: #e68a00; }
  .hl-vector   { background: rgba(66,165,245,0.2);  color: #1565c0; }
  .hl-layer    { background: rgba(171,71,188,0.2);  color: #7b1fa2; }
  .hl-predict  { background: rgba(102,187,106,0.2); color: #2e7d32; }
  .hl-cycle    { background: rgba(239,83,80,0.2);   color: #c62828; }

  #nav-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1.2rem 2.5rem;
    border-top: 1px solid #e0e0e0;
    background: #fff;
  }

  .nav-btn {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.65rem 1.5rem;
    border: 2px solid #222;
    border-radius: 8px;
    background: #fff;
    color: #222;
    font-size: 0.95rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    font-family: inherit;
  }

  .nav-btn:hover:not(:disabled) { background: #222; color: #fff; }
  .nav-btn:disabled { opacity: 0.25; cursor: default; }
  .nav-btn svg { width: 18px; height: 18px; fill: currentColor; }

  #progress { display: flex; gap: 0.6rem; align-items: center; }

  .dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: #ccc;
    transition: all 0.35s;
  }
  .dot.active { background: #222; transform: scale(1.3); }
  .dot.visited { background: #888; }

  #viz-panel { flex: 1; position: relative; height: 100vh; }
  #viz-panel canvas { display: block; }

  #narrative-content { transition: opacity 0.35s ease; }
  #narrative-content.fading { opacity: 0; }

  @media (max-width: 800px) {
    body { flex-direction: column; }
    #narrative-panel { width: 100%; height: 45vh; min-width: unset; }
    #viz-panel { height: 55vh; }
    #narrative-content { padding: 1.5rem; }
    .stage-title { font-size: 1.4rem; }
  }
</style>
</head>
<body>

<div id="narrative-panel">
  <div id="narrative-content"></div>
  <div id="nav-bar">
    <button class="nav-btn" id="btn-prev" disabled>
      <svg viewBox="0 0 24 24"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>
      Previous
    </button>
    <div id="progress"></div>
    <button class="nav-btn" id="btn-next">
      Next
      <svg viewBox="0 0 24 24"><path d="M8.59 16.59L10 18l6-6-6-6-1.41 1.41L13.17 12z"/></svg>
    </button>
  </div>
</div>

<div id="viz-panel"></div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

const STAGES = [
  {
    label: 'Stage 1 of 5',
    title: 'A sequence in embedding space',
    body: `<p>When you type a prompt, each <span class="highlight hl-token">token</span> is looked up in the embedding table and placed as a point in high-dimensional space.</p>
           <p>The tokens <strong>"The"</strong>, <strong>"cat"</strong>, and <strong>"sat"</strong> each occupy their own positions &mdash; shaped by everything the model learned about how they're used.</p>
           <p>But these are just starting positions. The model now needs to transform them, letting each token be influenced by the others.</p>`,
  },
  {
    label: 'Stage 2 of 5',
    title: 'Context flows through attention',
    body: `<p>The transformer's <span class="highlight hl-layer">attention mechanism</span> lets every token look at every other token and update itself accordingly.</p>
           <p><strong>"sat"</strong> can attend to <strong>"cat"</strong> and <strong>"The"</strong>, learning they provide important context. This produces a richer, contextual representation.</p>
           <p>After many layers, the final token's representation captures the full meaning of the sequence so far.</p>`,
  },
  {
    label: 'Stage 3 of 5',
    title: 'The last token is the predictor',
    body: `<p>After all transformer layers, the <span class="highlight hl-cycle">last token's</span> representation is used to predict the next word. It carries the contextual meaning of the entire sequence.</p>
           <p>This final vector is passed through a linear projection to produce <span class="highlight hl-predict">logits</span> &mdash; one score per word in the vocabulary.</p>
           <p>The model is essentially asking: "Given everything that came before, what word is most likely to come next?"</p>`,
  },
  {
    label: 'Stage 4 of 5',
    title: 'A probability distribution emerges',
    body: `<p>The logits are converted to <span class="highlight hl-predict">probabilities</span> via the softmax function. Each candidate word gets a score summing to 1.0.</p>
           <p>Words that fit the context well score high. <strong>"on"</strong> makes sense after "The cat sat". <strong>"unicycle"</strong> technically works but is unlikely.</p>
           <p>The distribution reflects the model's learned understanding of how language works.</p>`,
  },
  {
    label: 'Stage 5 of 5',
    title: 'Sample, then repeat',
    body: `<p>One token is <span class="highlight hl-cycle">sampled</span> from the distribution and appended to the sequence. Then the whole process repeats with the new, longer input.</p>
           <p>This is <strong>autoregressive generation</strong> &mdash; the model generates one token at a time, each conditioned on all previous tokens.</p>
           <p>Word by word, a response emerges &mdash; not planned in advance, but grown token by token through the geometry of language.</p>`,
  },
];

/* ====================== THREE.JS SETUP ====================== */

const vizPanel = document.getElementById('viz-panel');
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(vizPanel.clientWidth, vizPanel.clientHeight);
renderer.setClearColor(0x0a0a0f, 1);
vizPanel.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x0a0a0f, 0.007);

const camera3D = new THREE.PerspectiveCamera(50, vizPanel.clientWidth / vizPanel.clientHeight, 0.1, 200);
camera3D.position.set(0, 3, 18);

const controls = new OrbitControls(camera3D, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.enablePan = false;
controls.minDistance = 5;
controls.maxDistance = 40;

scene.add(new THREE.AmbientLight(0xffffff, 0.4));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(10, 15, 10);
scene.add(dirLight);
scene.add(new THREE.PointLight(0x4466ff, 0.3, 60)).position.set(-5, 8, 5);

const gridHelper = new THREE.GridHelper(30, 30, 0x222233, 0x151520);
gridHelper.material.transparent = true;
gridHelper.material.opacity = 0.25;
scene.add(gridHelper);

/* ====================== UTILITIES ====================== */

function makeTextSprite(text, color, fontSize = 28, bgOpacity = 0.75) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = 512; canvas.height = 64;
  ctx.font = `bold ${fontSize}px Inter, Arial, sans-serif`;
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  const metrics = ctx.measureText(text);
  const pw = metrics.width + 28, ph = 44;
  const px = (canvas.width - pw) / 2, py = (canvas.height - ph) / 2;
  ctx.fillStyle = `rgba(10,10,15,${bgOpacity})`;
  roundRect(ctx, px, py, pw, ph, 8); ctx.fill();
  const c = new THREE.Color(color);
  ctx.fillStyle = `rgb(${Math.floor(c.r*255)},${Math.floor(c.g*255)},${Math.floor(c.b*255)})`;
  ctx.fillText(text, canvas.width / 2, canvas.height / 2 + 1);
  const tex = new THREE.CanvasTexture(canvas);
  tex.minFilter = THREE.LinearFilter;
  const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false }));
  sprite.scale.set(4, 0.5, 1);
  return sprite;
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x+r, y); ctx.lineTo(x+w-r, y); ctx.quadraticCurveTo(x+w, y, x+w, y+r);
  ctx.lineTo(x+w, y+h-r); ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
  ctx.lineTo(x+r, y+h); ctx.quadraticCurveTo(x, y+h, x, y+h-r);
  ctx.lineTo(x, y+r); ctx.quadraticCurveTo(x, y, x+r, y); ctx.closePath();
}

function makeGlowSphere(radius, color, emissiveIntensity = 0.45) {
  const mat = new THREE.MeshStandardMaterial({
    color, emissive: color, emissiveIntensity, roughness: 0.25, metalness: 0.1,
  });
  const mesh = new THREE.Mesh(new THREE.SphereGeometry(radius, 32, 32), mat);
  const glowMat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.12 });
  mesh.add(new THREE.Mesh(new THREE.SphereGeometry(radius * 1.7, 32, 32), glowMat));
  return mesh;
}

/* ====================== WORD DATA ====================== */

const INPUT_TOKENS = [
  { word: 'The', color: 0xffb74d, pos: new THREE.Vector3(-5, 1, -1) },
  { word: 'cat', color: 0x42a5f5, pos: new THREE.Vector3(0, 2.5, 1) },
  { word: 'sat', color: 0x66bb6a, pos: new THREE.Vector3(4.5, 0.5, -0.5) },
];

const CANDIDATES = [
  { word: 'on',      prob: 0.45, pos: new THREE.Vector3(0, 6,  0),   color: 0x66bb6a },
  { word: 'down',    prob: 0.22, pos: new THREE.Vector3(2.5, 5.5, 1.5), color: 0x78909c },
  { word: 'quietly', prob: 0.12, pos: new THREE.Vector3(-2.5, 5.8, 1), color: 0x78909c },
  { word: 'back',    prob: 0.08, pos: new THREE.Vector3(1.8, 7, -1.5), color: 0x78909c },
  { word: 'there',   prob: 0.05, pos: new THREE.Vector3(-1.5, 7.5, -1), color: 0x78909c },
  { word: 'still',   prob: 0.04, pos: new THREE.Vector3(3.5, 6.5, -0.5), color: 0x78909c },
];

const GENERATED_SEQUENCE = ['The', 'cat', 'sat', 'on', 'the', 'mat'];
const GEN_COLORS = [0xffb74d, 0x42a5f5, 0x66bb6a, 0xef5350, 0xffa726, 0xab47bc];
const GEN_PATH = [
  new THREE.Vector3(-7, 0, 0),
  new THREE.Vector3(-4, 2.5, 1),
  new THREE.Vector3(-1, 1.5, -1),
  new THREE.Vector3(2.5, 3, 0.5),
  new THREE.Vector3(5, 1, -0.5),
  new THREE.Vector3(7.5, 2.5, 1),
];

/* ====================== STAGE GROUPS ====================== */

const stageGroup = new THREE.Group();
scene.add(stageGroup);

// --- Stage 1: Input tokens in embedding space ---
const s1Group = new THREE.Group();
stageGroup.add(s1Group);

const s1Spheres = INPUT_TOKENS.map(tok => {
  const sphere = makeGlowSphere(0.5, tok.color);
  sphere.position.copy(tok.pos);
  s1Group.add(sphere);
  const lbl = makeTextSprite(tok.word, tok.color, 28);
  lbl.scale.set(3.5, 0.5, 1);
  lbl.position.set(tok.pos.x, tok.pos.y + 1.1, tok.pos.z);
  s1Group.add(lbl);
  return sphere;
});

// Subtle axes
[[1,0,0,0x42a5f5],[0,1,0,0x66bb6a],[0,0,1,0xab47bc]].forEach(([x,y,z,col]) => {
  const dir = new THREE.Vector3(x,y,z);
  s1Group.add(new THREE.Line(
    new THREE.BufferGeometry().setFromPoints([dir.clone().multiplyScalar(-6), dir.clone().multiplyScalar(6)]),
    new THREE.LineBasicMaterial({ color: col, transparent: true, opacity: 0.12 })
  ));
});

// Sequence order arrows between tokens
for (let i = 0; i < INPUT_TOKENS.length - 1; i++) {
  const from = INPUT_TOKENS[i].pos;
  const to   = INPUT_TOKENS[i+1].pos;
  s1Group.add(new THREE.ArrowHelper(
    to.clone().sub(from).normalize(), from.clone(), from.distanceTo(to),
    0x555566, 0.4, 0.18
  ));
}

// --- Stage 2: Attention lines between all tokens ---
const s2Group = new THREE.Group();
stageGroup.add(s2Group);

const s2Spheres = INPUT_TOKENS.map(tok => {
  const sphere = makeGlowSphere(0.5, tok.color);
  sphere.position.copy(tok.pos);
  s2Group.add(sphere);
  const lbl = makeTextSprite(tok.word, tok.color, 28);
  lbl.scale.set(3.5, 0.5, 1);
  lbl.position.set(tok.pos.x, tok.pos.y + 1.1, tok.pos.z);
  s2Group.add(lbl);
  return sphere;
});

// Attention lines between all pairs
const attentionLinesS2 = [];
for (let i = 0; i < INPUT_TOKENS.length; i++) {
  for (let j = 0; j < INPUT_TOKENS.length; j++) {
    if (i === j) continue;
    const strength = i < j ? 0.7 : 0.3; // forward attention stronger
    const col = new THREE.Color(INPUT_TOKENS[i].color).lerp(new THREE.Color(INPUT_TOKENS[j].color), 0.5);
    const line = new THREE.Line(
      new THREE.BufferGeometry().setFromPoints([INPUT_TOKENS[i].pos.clone(), INPUT_TOKENS[j].pos.clone()]),
      new THREE.LineBasicMaterial({ color: col, transparent: true, opacity: 0 })
    );
    line.userData = { baseOpacity: strength * 0.45, i, j };
    s2Group.add(line);
    attentionLinesS2.push(line);
  }
}

// --- Stage 3: Last token glows, projects up ---
const s3Group = new THREE.Group();
stageGroup.add(s3Group);

INPUT_TOKENS.forEach((tok, idx) => {
  const sphere = makeGlowSphere(idx === 2 ? 0.65 : 0.45, tok.color, idx === 2 ? 0.7 : 0.3);
  sphere.position.copy(tok.pos);
  s3Group.add(sphere);
  const lbl = makeTextSprite(tok.word, tok.color, idx === 2 ? 32 : 26);
  lbl.scale.set(3.5, 0.5, 1);
  lbl.position.set(tok.pos.x, tok.pos.y + 1.2, tok.pos.z);
  s3Group.add(lbl);
});

// Projection beam from last token upward
const beamPts = [INPUT_TOKENS[2].pos.clone(), INPUT_TOKENS[2].pos.clone().add(new THREE.Vector3(0, 5, 0))];
const beamLine = new THREE.Line(
  new THREE.BufferGeometry().setFromPoints(beamPts),
  new THREE.LineBasicMaterial({ color: 0x66bb6a, transparent: true, opacity: 0.5 })
);
s3Group.add(beamLine);

const logitsLabel = makeTextSprite('â†’ logits over vocabulary', 0x66bb6a, 22, 0.7);
logitsLabel.scale.set(5.5, 0.5, 1);
logitsLabel.position.set(INPUT_TOKENS[2].pos.x + 3, INPUT_TOKENS[2].pos.y + 4, INPUT_TOKENS[2].pos.z);
s3Group.add(logitsLabel);

// --- Stage 4: Probability cloud ---
const s4Group = new THREE.Group();
stageGroup.add(s4Group);

// Last token as anchor
const s4Anchor = makeGlowSphere(0.6, 0x66bb6a, 0.6);
s4Anchor.position.copy(INPUT_TOKENS[2].pos);
s4Group.add(s4Anchor);
const anchorLbl = makeTextSprite('"sat"', 0x66bb6a, 28);
anchorLbl.scale.set(3.5, 0.5, 1);
anchorLbl.position.set(INPUT_TOKENS[2].pos.x, INPUT_TOKENS[2].pos.y + 1.2, INPUT_TOKENS[2].pos.z);
s4Group.add(anchorLbl);

const s4CandMeshes = [];
const s4CandLabels = [];

CANDIDATES.forEach(c => {
  const size = 0.18 + c.prob * 0.7;
  const isTop = c.word === 'on';
  const mesh = makeGlowSphere(size, c.color, isTop ? 0.7 : 0.25);
  mesh.position.copy(c.pos);
  s4Group.add(mesh);
  s4CandMeshes.push(mesh);

  // Line to anchor
  const lineCol = new THREE.Color(c.color);
  s4Group.add(new THREE.Line(
    new THREE.BufferGeometry().setFromPoints([INPUT_TOKENS[2].pos.clone(), c.pos.clone()]),
    new THREE.LineBasicMaterial({ color: lineCol, transparent: true, opacity: isTop ? 0.45 : 0.12 })
  ));

  const probLabel = makeTextSprite(`"${c.word}" ${Math.round(c.prob*100)}%`, isTop ? 0x66bb6a : 0x888888, isTop ? 26 : 20, 0.65);
  probLabel.scale.set(isTop ? 3.8 : 3.2, isTop ? 0.5 : 0.38, 1);
  probLabel.position.set(c.pos.x, c.pos.y + size + 0.7, c.pos.z);
  s4Group.add(probLabel);
  s4CandLabels.push(probLabel);
});

// --- Stage 5: Growing sequence ---
const s5Group = new THREE.Group();
stageGroup.add(s5Group);

const s5Spheres = [];
const s5Labels  = [];

GENERATED_SEQUENCE.forEach((word, i) => {
  const sphere = makeGlowSphere(0.42, GEN_COLORS[i]);
  sphere.position.copy(GEN_PATH[i]);
  s5Group.add(sphere);
  s5Spheres.push(sphere);

  const lbl = makeTextSprite(`"${word}"`, GEN_COLORS[i], 26);
  lbl.scale.set(3.5, 0.45, 1);
  lbl.position.set(GEN_PATH[i].x, GEN_PATH[i].y + 0.95, GEN_PATH[i].z);
  s5Group.add(lbl);
  s5Labels.push(lbl);
});

// Path lines
const s5LineGroup = new THREE.Group();
s5Group.add(s5LineGroup);
for (let i = 0; i < GEN_PATH.length - 1; i++) {
  const mid = new THREE.Vector3().lerpVectors(GEN_PATH[i], GEN_PATH[i+1], 0.5);
  mid.y += 0.6;
  const curve = new THREE.QuadraticBezierCurve3(GEN_PATH[i], mid, GEN_PATH[i+1]);
  const c1 = new THREE.Color(GEN_COLORS[i]).lerp(new THREE.Color(GEN_COLORS[i+1]), 0.5);
  s5LineGroup.add(new THREE.Line(
    new THREE.BufferGeometry().setFromPoints(curve.getPoints(20)),
    new THREE.LineBasicMaterial({ color: c1, transparent: true, opacity: 0 })
  ));
}

// Mini transformer blocks between tokens
const s5BlockGroup = new THREE.Group();
s5Group.add(s5BlockGroup);
for (let i = 0; i < GEN_PATH.length - 1; i++) {
  const mid = new THREE.Vector3().lerpVectors(GEN_PATH[i], GEN_PATH[i+1], 0.5);
  mid.y += 0.6;
  const box = new THREE.Mesh(
    new THREE.BoxGeometry(0.35, 0.7, 0.35),
    new THREE.MeshStandardMaterial({ color: 0x6644aa, emissive: 0x6644aa, emissiveIntensity: 0.25, transparent: true, opacity: 0, roughness: 0.5 })
  );
  box.position.copy(mid);
  s5BlockGroup.add(box);
}

/* ====================== STAGE CONFIG ====================== */

const stageGroups = [s1Group, s2Group, s3Group, s4Group, s5Group];

const stageConfigs = [
  { camera: { x: 0, y: 4, z: 16 }, target: { x: 0, y: 1.5, z: 0 }, autoRotate: true },
  { camera: { x: 5, y: 5, z: 14 }, target: { x: 0, y: 1.5, z: 0 }, autoRotate: true },
  { camera: { x: 6, y: 3, z: 14 }, target: { x: 2, y: 2, z: 0 },   autoRotate: false },
  { camera: { x: 4, y: 5, z: 14 }, target: { x: 1, y: 4, z: 0 },   autoRotate: true },
  { camera: { x: 1, y: 5, z: 16 }, target: { x: 0, y: 1.5, z: 0 }, autoRotate: true },
];

function setStageVisibility(idx) {
  stageGroups.forEach((g, i) => { g.visible = i === idx; });
}

/* ====================== NAVIGATION ====================== */

let currentStage = 0;
const cameraTarget  = new THREE.Vector3(0, 4, 16);
const controlsTarget = new THREE.Vector3(0, 1.5, 0);

const narrativeContent = document.getElementById('narrative-content');
const btnPrev = document.getElementById('btn-prev');
const btnNext = document.getElementById('btn-next');
const progressContainer = document.getElementById('progress');

STAGES.forEach((_, i) => {
  const dot = document.createElement('div');
  dot.className = 'dot' + (i === 0 ? ' active' : '');
  dot.addEventListener('click', () => goToStage(i));
  dot.style.cursor = 'pointer';
  progressContainer.appendChild(dot);
});

function updateNarrative(idx) {
  const s = STAGES[idx];
  narrativeContent.classList.add('fading');
  setTimeout(() => {
    narrativeContent.innerHTML = `<div class="stage-label">${s.label}</div><h2 class="stage-title">${s.title}</h2><div class="stage-body">${s.body}</div>`;
    narrativeContent.classList.remove('fading');
  }, 300);
}

function updateProgress(idx) {
  progressContainer.querySelectorAll('.dot').forEach((d, i) => {
    d.classList.remove('active', 'visited');
    if (i === idx) d.classList.add('active');
    else if (i < idx) d.classList.add('visited');
  });
}

function updateButtons(idx) {
  btnPrev.disabled = idx === 0;
  btnNext.disabled = idx === STAGES.length - 1;
  btnNext.innerHTML = idx === STAGES.length - 1
    ? 'Done'
    : 'Next <svg viewBox="0 0 24 24"><path d="M8.59 16.59L10 18l6-6-6-6-1.41 1.41L13.17 12z"/></svg>';
}

function goToStage(idx) {
  if (idx < 0 || idx >= STAGES.length || idx === currentStage) return;
  currentStage = idx;
  const cfg = stageConfigs[idx];
  cameraTarget.set(cfg.camera.x, cfg.camera.y, cfg.camera.z);
  controlsTarget.set(cfg.target.x, cfg.target.y, cfg.target.z);
  setStageVisibility(idx);
  updateNarrative(idx);
  updateProgress(idx);
  updateButtons(idx);
  stageStartTime = clock.getElapsedTime();
}

let stageStartTime = 0;
setStageVisibility(0);
updateNarrative(0);
updateProgress(0);
updateButtons(0);

btnNext.addEventListener('click', () => goToStage(currentStage + 1));
btnPrev.addEventListener('click', () => goToStage(currentStage - 1));

document.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowRight' || e.key === ' ') { e.preventDefault(); goToStage(currentStage + 1); }
  else if (e.key === 'ArrowLeft') { e.preventDefault(); goToStage(currentStage - 1); }
});

window.addEventListener('resize', () => {
  const w = vizPanel.clientWidth, h = vizPanel.clientHeight;
  camera3D.aspect = w / h;
  camera3D.updateProjectionMatrix();
  renderer.setSize(w, h);
});

/* ====================== RENDER LOOP ====================== */

const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const dt = Math.min(clock.getDelta(), 0.05);
  const t = clock.getElapsedTime();
  const stageT = t - stageStartTime;
  const lerpSpeed = 2.5 * dt;

  camera3D.position.lerp(cameraTarget, lerpSpeed * 0.7);
  controls.target.lerp(controlsTarget, lerpSpeed * 0.7);
  controls.autoRotate = stageConfigs[currentStage].autoRotate;
  gridHelper.rotation.y = t * 0.015;

  if (currentStage === 0) {
    s1Spheres.forEach((s, i) => {
      const base = INPUT_TOKENS[i].pos;
      s.position.set(base.x + Math.sin(t * 0.8 + i*1.5) * 0.12, base.y + Math.sin(t * 1.0 + i*2) * 0.18, base.z + Math.cos(t * 0.7 + i) * 0.12);
      if (s.children[0]) s.children[0].material.opacity = 0.08 + Math.sin(t*2+i)*0.05;
    });
  }

  if (currentStage === 1) {
    s2Spheres.forEach((s, i) => {
      const base = INPUT_TOKENS[i].pos;
      s.position.set(base.x + Math.sin(t*0.8+i*1.5)*0.12, base.y + Math.sin(t*1.0+i*2)*0.18, base.z + Math.cos(t*0.7+i)*0.12);
      if (s.children[0]) s.children[0].material.opacity = 0.08 + Math.sin(t*2+i)*0.05;
    });
    // Animate attention lines pulsing
    attentionLinesS2.forEach((line, li) => {
      const pulse = Math.sin(t * 2.5 + li * 0.7) * 0.5 + 0.5;
      line.material.opacity = line.userData.baseOpacity * pulse;
    });
  }

  if (currentStage === 2) {
    // Pulse beam from last token
    const beamPulse = 0.35 + Math.sin(t * 3) * 0.2;
    beamLine.material.opacity = beamPulse;
  }

  if (currentStage === 3) {
    s4Anchor.scale.setScalar(1 + Math.sin(t * 2.5) * 0.1);
    if (s4Anchor.children[0]) s4Anchor.children[0].material.opacity = 0.08 + Math.sin(t*2)*0.05;
    s4CandMeshes.forEach((mesh, i) => {
      const c = CANDIDATES[i];
      mesh.position.set(c.pos.x + Math.sin(t*0.7+i*1.8)*0.18, c.pos.y + Math.sin(t*0.9+i*1.3)*0.15, c.pos.z + Math.cos(t*0.6+i)*0.15);
      if (c.word === 'on') { mesh.scale.setScalar(1 + Math.sin(t*3)*0.12); }
      s4CandLabels[i].position.set(mesh.position.x, mesh.position.y + (0.18+c.prob*0.7) + 0.7, mesh.position.z);
    });
  }

  if (currentStage === 4) {
    const tokenInterval = 1.1;
    s5Spheres.forEach((sphere, i) => {
      const delay = i * tokenInterval;
      const tokT = Math.max(0, stageT - delay);
      const fadeIn = Math.min(tokT / 0.5, 1);
      sphere.scale.setScalar(fadeIn);
      const base = GEN_PATH[i];
      sphere.position.set(base.x + Math.sin(t*0.7+i*1.5)*0.1, base.y + Math.sin(t*0.9+i*2)*0.13, base.z + Math.cos(t*0.6+i)*0.1);
      s5Labels[i].position.set(sphere.position.x, sphere.position.y + 0.95, sphere.position.z);
      s5Labels[i].material.opacity = fadeIn;
      if (sphere.children[0]) sphere.children[0].material.opacity = 0.08 * fadeIn;
    });
    s5LineGroup.children.forEach((line, i) => {
      const delay = (i+1) * tokenInterval;
      line.material.opacity = Math.min(Math.max(0, stageT - delay) / 0.5, 1) * 0.45;
    });
    s5BlockGroup.children.forEach((box, i) => {
      const delay = (i + 0.5) * tokenInterval;
      const bT = Math.max(0, stageT - delay);
      const fi = Math.min(bT / 0.5, 1);
      box.scale.setScalar(fi);
      box.material.opacity = fi * 0.5;
      box.rotation.y = t * 1.5 + i;
    });
  }

  controls.update();
  renderer.render(scene, camera3D);
}

animate();
</script>
</body>
</html>
